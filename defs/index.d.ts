/// <reference types="node" />
import * as crypto from 'crypto';
import { ec as EC } from 'elliptic';
import { AESCryptOptions, PBKInput } from './types';
import { Serializer, DataCoder, coderTools, nTools } from '@osmium/coder';
import { DetectorCallback } from '@osmium/coder/src/types';
import { BinaryToTextEncoding } from 'crypto';
export { Serializer, DataCoder, coderTools, nTools };
declare function pbkdf2(password: PBKInput, salt?: PBKInput, iterations?: number, keyLength?: number, digest?: string): Promise<boolean | Buffer>;
declare function pbkdf2b66(password: PBKInput, salt?: PBKInput, iterations?: number, keyLength?: number, digest?: string): Promise<string | boolean>;
export declare const cryptTools: {
    BASE_ALPHABETS: {
        BASE16: string;
        BASE36: string;
        BASE58: string;
        BASE62: string;
        BASE66: string;
    };
    BaseX: typeof import("@osmium/coder/defs/lib/base-x").default;
    base16Encode: (what: string | Buffer, asAscii?: boolean | undefined) => string;
    base32Encode: (what: string | Buffer, asAscii?: boolean | undefined) => string;
    base36Encode: (what: string | Buffer, asAscii?: boolean | undefined) => string;
    base58Encode: (what: string | Buffer, asAscii?: boolean | undefined) => string;
    base62Encode: (what: string | Buffer, asAscii?: boolean | undefined) => string;
    base64Encode: (what: string | Buffer, asAscii?: boolean | undefined) => string;
    base66Encode: (what: string | Buffer, asAscii?: boolean | undefined) => string;
    base16Decode: (what: string, asBuffer?: boolean | undefined, asAscii?: boolean | undefined) => import("@osmium/coder/defs/types").DecodeResult;
    base32Decode: (what: string, asBuffer?: boolean | undefined, asAscii?: boolean | undefined) => Uint8Array | import("@osmium/coder/defs/types").DecodeResult;
    base36Decode: (what: string, asBuffer?: boolean | undefined, asAscii?: boolean | undefined) => import("@osmium/coder/defs/types").DecodeResult;
    base58Decode: (what: string, asBuffer?: boolean | undefined, asAscii?: boolean | undefined) => Uint8Array | import("@osmium/coder/defs/types").DecodeResult;
    base62Decode: (what: string, asBuffer?: boolean | undefined, asAscii?: boolean | undefined) => import("@osmium/coder/defs/types").DecodeResult;
    base64Decode: (what: string, asBuffer?: boolean | undefined, asAscii?: boolean | undefined) => Uint8Array | import("@osmium/coder/defs/types").DecodeResult;
    base66Decode: (what: string, asBuffer?: boolean | undefined, asAscii?: boolean | undefined) => import("@osmium/coder/defs/types").DecodeResult;
    twoInt32toInt53: (val: number[]) => number;
    int53toTwoInt32: (val: number) => number[];
    intToBuf: (int: number, len?: number | undefined, be?: boolean | undefined) => Buffer;
    int8ToBuf: (int: number) => Buffer;
    int8UToBuf: (int: number) => Buffer;
    int16ToBuf: (int: number, be?: boolean | undefined) => Buffer;
    int16UToBuf: (int: number, be?: boolean | undefined) => Buffer;
    int32ToBuf: (int: number, be?: boolean | undefined) => Buffer;
    int32UToBuf: (int: number, be?: boolean | undefined) => Buffer;
    floatToBuf: (int: number, be?: boolean | undefined) => Buffer;
    doubleToBuf: (int: number, be?: boolean | undefined) => Buffer;
    bufToInt8: (buf: Buffer, offset?: number | undefined) => number;
    bufToInt8U: (buf: Buffer, offset?: number | undefined) => number;
    bufToInt16: (buf: Buffer, offset?: number | undefined, be?: boolean | undefined) => number;
    bufToInt16U: (buf: Buffer, offset?: number | undefined, be?: boolean | undefined) => number;
    bufToInt32: (buf: Buffer, offset?: number | undefined, be?: boolean | undefined) => number;
    bufToInt32U: (buf: Buffer, offset?: number | undefined, be?: boolean | undefined) => number;
    bufToInt: (buf: Buffer, len?: number | undefined, offset?: number | undefined, be?: boolean | undefined) => number;
    bufToFloat: (buf: Buffer, offset?: number | undefined, be?: boolean | undefined) => number;
    bufToDouble: (buf: Buffer, offset?: number | undefined, be?: boolean | undefined) => number;
    pad: (str: string, z?: number | undefined) => string;
    bufToBinFlags: (buf: Buffer, offset: number) => Boolean[];
    binFlagsToBuf: (arr: boolean[]) => Buffer;
    hexToBinStr: (val: string) => string;
    crc32: any;
} & {
    crypto: typeof crypto;
    pbkdf2: typeof pbkdf2;
    pbkdf2b66: typeof pbkdf2b66;
    hash: (what: any, mode?: string, encoding?: crypto.Encoding, digest?: crypto.BinaryToTextEncoding) => string;
    isHash: (what: any, type?: string) => boolean;
};
export declare class AesCrypt {
    options: AESCryptOptions & object;
    private readonly coder;
    private readonly serializer;
    constructor(options?: {});
    use<T>(id: number, detector: DetectorCallback, encode: (arg: T) => Buffer, decode: (arg: Buffer) => T): void;
    genKey(passkey: PBKInput, id?: boolean): Promise<boolean | Buffer>;
    private _process;
    encrypt<T>(key: PBKInput | Function, data: T, id?: boolean, publicData?: boolean, useDataCoder?: boolean): Promise<Boolean | Buffer>;
    slicePublicData<T>(data: Buffer): Promise<T | null>;
    decrypt(key: PBKInput | Function, data: Buffer, returnExtended?: boolean): Promise<Buffer | {
        id: any;
        iv: any;
        publicData: any;
        payload: Buffer;
    } | null>;
}
export declare type ECDH_KeyPair = {
    privKey: string;
    pubKey: string;
};
export declare class ECDH_Key {
    ser: Serializer;
    VERSION: Number;
    CURVE: string;
    ec: EC;
    constructor();
    private hexToB62;
    private b62PrivToHex;
    generate(): ECDH_KeyPair;
    static generate(): ECDH_KeyPair;
    getPublicFromPrivate(privKey: string): ECDH_KeyPair;
    static getPublicFromPrivate(privKey: string): ECDH_KeyPair;
}
export declare class ECDH_KeyDerivation {
    private serializer;
    keyFormatVersion: number;
    ec: EC | boolean;
    curve: any;
    ourKey: EC.KeyPair;
    theirKey: EC.KeyPair;
    sharedKey: Buffer | boolean;
    static createInstance(keyPair: ECDH_KeyPair): ECDH_KeyDerivation;
    constructor(ourPrivate: string | Buffer, theirPublic: string | Buffer);
    private _decodePayload;
    getSharedKey(): Buffer;
}
declare const _default: {
    Serializer: typeof Serializer;
    DataCoder: typeof DataCoder;
    coderTools: {
        BASE_ALPHABETS: {
            BASE16: string;
            BASE36: string;
            BASE58: string;
            BASE62: string;
            BASE66: string;
        };
        BaseX: typeof import("@osmium/coder/defs/lib/base-x").default;
        base16Encode: (what: string | Buffer, asAscii?: boolean | undefined) => string;
        base32Encode: (what: string | Buffer, asAscii?: boolean | undefined) => string;
        base36Encode: (what: string | Buffer, asAscii?: boolean | undefined) => string;
        base58Encode: (what: string | Buffer, asAscii?: boolean | undefined) => string;
        base62Encode: (what: string | Buffer, asAscii?: boolean | undefined) => string;
        base64Encode: (what: string | Buffer, asAscii?: boolean | undefined) => string;
        base66Encode: (what: string | Buffer, asAscii?: boolean | undefined) => string;
        base16Decode: (what: string, asBuffer?: boolean | undefined, asAscii?: boolean | undefined) => import("@osmium/coder/defs/types").DecodeResult;
        base32Decode: (what: string, asBuffer?: boolean | undefined, asAscii?: boolean | undefined) => Uint8Array | import("@osmium/coder/defs/types").DecodeResult;
        base36Decode: (what: string, asBuffer?: boolean | undefined, asAscii?: boolean | undefined) => import("@osmium/coder/defs/types").DecodeResult;
        base58Decode: (what: string, asBuffer?: boolean | undefined, asAscii?: boolean | undefined) => Uint8Array | import("@osmium/coder/defs/types").DecodeResult;
        base62Decode: (what: string, asBuffer?: boolean | undefined, asAscii?: boolean | undefined) => import("@osmium/coder/defs/types").DecodeResult;
        base64Decode: (what: string, asBuffer?: boolean | undefined, asAscii?: boolean | undefined) => Uint8Array | import("@osmium/coder/defs/types").DecodeResult;
        base66Decode: (what: string, asBuffer?: boolean | undefined, asAscii?: boolean | undefined) => import("@osmium/coder/defs/types").DecodeResult;
        twoInt32toInt53: (val: number[]) => number;
        int53toTwoInt32: (val: number) => number[];
        intToBuf: (int: number, len?: number | undefined, be?: boolean | undefined) => Buffer;
        int8ToBuf: (int: number) => Buffer;
        int8UToBuf: (int: number) => Buffer;
        int16ToBuf: (int: number, be?: boolean | undefined) => Buffer;
        int16UToBuf: (int: number, be?: boolean | undefined) => Buffer;
        int32ToBuf: (int: number, be?: boolean | undefined) => Buffer;
        int32UToBuf: (int: number, be?: boolean | undefined) => Buffer;
        floatToBuf: (int: number, be?: boolean | undefined) => Buffer;
        doubleToBuf: (int: number, be?: boolean | undefined) => Buffer;
        bufToInt8: (buf: Buffer, offset?: number | undefined) => number;
        bufToInt8U: (buf: Buffer, offset?: number | undefined) => number;
        bufToInt16: (buf: Buffer, offset?: number | undefined, be?: boolean | undefined) => number;
        bufToInt16U: (buf: Buffer, offset?: number | undefined, be?: boolean | undefined) => number;
        bufToInt32: (buf: Buffer, offset?: number | undefined, be?: boolean | undefined) => number;
        bufToInt32U: (buf: Buffer, offset?: number | undefined, be?: boolean | undefined) => number;
        bufToInt: (buf: Buffer, len?: number | undefined, offset?: number | undefined, be?: boolean | undefined) => number;
        bufToFloat: (buf: Buffer, offset?: number | undefined, be?: boolean | undefined) => number;
        bufToDouble: (buf: Buffer, offset?: number | undefined, be?: boolean | undefined) => number;
        pad: (str: string, z?: number | undefined) => string;
        bufToBinFlags: (buf: Buffer, offset: number) => Boolean[];
        binFlagsToBuf: (arr: boolean[]) => Buffer;
        hexToBinStr: (val: string) => string;
        crc32: any;
    };
    nTools: typeof nTools;
    cryptTools: {
        BASE_ALPHABETS: {
            BASE16: string;
            BASE36: string;
            BASE58: string;
            BASE62: string;
            BASE66: string;
        };
        BaseX: typeof import("@osmium/coder/defs/lib/base-x").default;
        base16Encode: (what: string | Buffer, asAscii?: boolean | undefined) => string;
        base32Encode: (what: string | Buffer, asAscii?: boolean | undefined) => string;
        base36Encode: (what: string | Buffer, asAscii?: boolean | undefined) => string;
        base58Encode: (what: string | Buffer, asAscii?: boolean | undefined) => string;
        base62Encode: (what: string | Buffer, asAscii?: boolean | undefined) => string;
        base64Encode: (what: string | Buffer, asAscii?: boolean | undefined) => string;
        base66Encode: (what: string | Buffer, asAscii?: boolean | undefined) => string;
        base16Decode: (what: string, asBuffer?: boolean | undefined, asAscii?: boolean | undefined) => import("@osmium/coder/defs/types").DecodeResult;
        base32Decode: (what: string, asBuffer?: boolean | undefined, asAscii?: boolean | undefined) => Uint8Array | import("@osmium/coder/defs/types").DecodeResult;
        base36Decode: (what: string, asBuffer?: boolean | undefined, asAscii?: boolean | undefined) => import("@osmium/coder/defs/types").DecodeResult;
        base58Decode: (what: string, asBuffer?: boolean | undefined, asAscii?: boolean | undefined) => Uint8Array | import("@osmium/coder/defs/types").DecodeResult;
        base62Decode: (what: string, asBuffer?: boolean | undefined, asAscii?: boolean | undefined) => import("@osmium/coder/defs/types").DecodeResult;
        base64Decode: (what: string, asBuffer?: boolean | undefined, asAscii?: boolean | undefined) => Uint8Array | import("@osmium/coder/defs/types").DecodeResult;
        base66Decode: (what: string, asBuffer?: boolean | undefined, asAscii?: boolean | undefined) => import("@osmium/coder/defs/types").DecodeResult;
        twoInt32toInt53: (val: number[]) => number;
        int53toTwoInt32: (val: number) => number[];
        intToBuf: (int: number, len?: number | undefined, be?: boolean | undefined) => Buffer;
        int8ToBuf: (int: number) => Buffer;
        int8UToBuf: (int: number) => Buffer;
        int16ToBuf: (int: number, be?: boolean | undefined) => Buffer;
        int16UToBuf: (int: number, be?: boolean | undefined) => Buffer;
        int32ToBuf: (int: number, be?: boolean | undefined) => Buffer;
        int32UToBuf: (int: number, be?: boolean | undefined) => Buffer;
        floatToBuf: (int: number, be?: boolean | undefined) => Buffer;
        doubleToBuf: (int: number, be?: boolean | undefined) => Buffer;
        bufToInt8: (buf: Buffer, offset?: number | undefined) => number;
        bufToInt8U: (buf: Buffer, offset?: number | undefined) => number;
        bufToInt16: (buf: Buffer, offset?: number | undefined, be?: boolean | undefined) => number;
        bufToInt16U: (buf: Buffer, offset?: number | undefined, be?: boolean | undefined) => number;
        bufToInt32: (buf: Buffer, offset?: number | undefined, be?: boolean | undefined) => number;
        bufToInt32U: (buf: Buffer, offset?: number | undefined, be?: boolean | undefined) => number;
        bufToInt: (buf: Buffer, len?: number | undefined, offset?: number | undefined, be?: boolean | undefined) => number;
        bufToFloat: (buf: Buffer, offset?: number | undefined, be?: boolean | undefined) => number;
        bufToDouble: (buf: Buffer, offset?: number | undefined, be?: boolean | undefined) => number;
        pad: (str: string, z?: number | undefined) => string;
        bufToBinFlags: (buf: Buffer, offset: number) => Boolean[];
        binFlagsToBuf: (arr: boolean[]) => Buffer;
        hexToBinStr: (val: string) => string;
        crc32: any;
    } & {
        crypto: typeof crypto;
        pbkdf2: typeof pbkdf2;
        pbkdf2b66: typeof pbkdf2b66;
        hash: (what: any, mode?: string, encoding?: crypto.Encoding, digest?: crypto.BinaryToTextEncoding) => string;
        isHash: (what: any, type?: string) => boolean;
    };
    ECDH_Key: typeof ECDH_Key;
    ECDH_KeyDerivation: typeof ECDH_KeyDerivation;
};
export default _default;
